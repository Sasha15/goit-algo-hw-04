# Загальна ефективність алгоритмів

- **Insertion Sort**

  - Має квадратичну складність `O(n²)` у середньому та гіршому випадку.
  - Працює добре лише для дуже малих або майже відсортованих масивів.
  - Уже при `n ≈ 1000` час виконання суттєво зростає, що робить алгоритм непридатним для більших задач.

- **Merge Sort**

  - Завжди гарантує `O(n log n)` незалежно від характеру вхідних даних.
  - У тестах показав адекватну швидкість сортування навіть для `n = 20 000`.
  - Проте константні множники (виділення допоміжних масивів, рекурсія) дають невелику “затримку” порівняно з Timsort.

- **Timsort** (вбудований у Python через `sorted()` / `list.sort()`)
  - У найгіршому випадку також працює за `O(n log n)`.
  - Розпізнає вже відсортовані підмасиви (“runs”) і для невеликих фрагментів використовує Insertion Sort.
  - Завдяки цим оптимізаціям практично завжди випереджає “чистий” Merge Sort на випадкових даних.

---

# Емпіричне підтвердження теоретичних оцінок

1. **n = 1000**

   - Insertion Sort (3 запуски): ~0.18 с
   - Merge Sort (3 запуски): ~0.01–0.02 с
   - Timsort (3 запуски): ~0.002 с

   Уже при `n = 1000` Insertion Sort займає близько 0.18 с, тоді як Merge Sort — 0.01–0.02 с, а Timsort — лише 0.002 с.

2. **n = 5000–20 000**
   - Різниця між Merge Sort і Timsort зростає із збільшенням даних.
   - При `n = 20 000`:
     - Merge Sort: ~0.4 с
     - Timsort: < 0.15 с
   - Insertion Sort на таких обсягах не заміряли через неприйнятно довгий час.

> **Висновок:**  
> Завдяки поєднанню злиття, вставок і виявленню “runs” Timsort застосовує оптимізації, яких немає в “чистому” Merge Sort. Це пояснює суттєво кращу практичну продуктивність Timsort.

---

# Коли доречно використовувати кожен алгоритм

- **Insertion Sort**

  - Доречний тільки якщо гарантовано `n ≲ 1000` або дані вже майже відсортовані.
  - Приклади:
    - Дуже малі масиви в embedded-системах.
    - Як частина гібридних алгоритмів (Timsort, Quick Sort із “хвостовим” Insertion Sort).

- **Merge Sort**

  - Потрібна гарантована `O(n log n)` та стабільність сортування.
  - В Python краще використовувати вбудовані методи через їхні внутрішні оптимізації.

- **Timsort**
  - Універсальний “із коробки” варіант для будь-якого `n`.
  - Автоматично адаптується до випадкових і майже відсортованих послідовностей.
  - Забезпечує стабільність (зберігає порядок однакових елементів).
  - Рекомендується як стандартне сортування в Python.

---

# Об’єднання k відсортованих списків (`merge_k_lists`)

- **Підхід “Divide and Conquer”**

  - Алгоритм не сортує кожний окремий список із нуля, а поетапно зливає вже відсортовані фрагменти.
  - Рекурсивно ділить набір списків на дві частини, зливає “лівий” і “правий”, після чого повертає результат.

- **Висновок**
  - Якщо потрібно об’єднати кілька вже відсортованих послідовностей (наприклад, результати з різних баз даних), виклик `merge_k_lists` значно прискорює обробку та знижує споживання пам’яті.
